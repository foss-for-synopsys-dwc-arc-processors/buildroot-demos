From a3ff13a25dbb6e89c3eb007d2af9fdc4cd19848f Mon Sep 17 00:00:00 2001
From: Evgeniy Didin <Evgeniy.Didin@synopsys.com>
Date: Fri, 20 Apr 2018 18:43:08 +0300
Subject: [PATCH] ARC: enable dualslot for sdio

---
 drivers/mmc/host/dw_mmc.c | 530 +++++++++++++++++++++++++++++++---------------
 drivers/mmc/host/dw_mmc.h |  34 ++-
 2 files changed, 384 insertions(+), 180 deletions(-)

diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
index 06d47414d0c1..e0d30f56cc59 100644
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@ -147,19 +147,7 @@ static int dw_mci_req_show(struct seq_file *s, void *v)
 
 	return 0;
 }
-
-static int dw_mci_req_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, dw_mci_req_show, inode->i_private);
-}
-
-static const struct file_operations dw_mci_req_fops = {
-	.owner		= THIS_MODULE,
-	.open		= dw_mci_req_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(dw_mci_req);
 
 static int dw_mci_regs_show(struct seq_file *s, void *v)
 {
@@ -178,19 +166,7 @@ static int dw_mci_regs_show(struct seq_file *s, void *v)
 
 	return 0;
 }
-
-static int dw_mci_regs_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, dw_mci_regs_show, inode->i_private);
-}
-
-static const struct file_operations dw_mci_regs_fops = {
-	.owner		= THIS_MODULE,
-	.open		= dw_mci_regs_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(dw_mci_regs);
 
 static void dw_mci_init_debugfs(struct dw_mci_slot *slot)
 {
@@ -285,7 +261,8 @@ static void mci_send_cmd(struct dw_mci_slot *slot, u32 cmd, u32 arg)
 	mci_writel(host, CMDARG, arg);
 	wmb(); /* drain writebuffer */
 	dw_mci_wait_while_busy(host, cmd);
-	mci_writel(host, CMD, SDMMC_CMD_START | cmd);
+	mci_writel(host, CMD, SDMMC_CMD_START | cmd |
+			      (slot->id << SDMMC_CMD_CARD_NUM_OFFSET));
 
 	if (readl_poll_timeout_atomic(host->regs + SDMMC_CMD, cmd_status,
 				      !(cmd_status & SDMMC_CMD_START),
@@ -396,7 +373,7 @@ static u32 dw_mci_prep_stop_abort(struct dw_mci *host, struct mmc_command *cmd)
 	cmdr = stop->opcode | SDMMC_CMD_STOP |
 		SDMMC_CMD_RESP_CRC | SDMMC_CMD_RESP_EXP;
 
-	if (!test_bit(DW_MMC_CARD_NO_USE_HOLD, &host->slot->flags))
+	if (!test_bit(DW_MMC_CARD_NO_USE_HOLD, &host->cur_slot->flags))
 		cmdr |= SDMMC_CMD_USE_HOLD_REG;
 
 	return cmdr;
@@ -452,7 +429,8 @@ static void dw_mci_start_command(struct dw_mci *host,
 	wmb(); /* drain writebuffer */
 	dw_mci_wait_while_busy(host, cmd_flags);
 
-	mci_writel(host, CMD, cmd_flags | SDMMC_CMD_START);
+	mci_writel(host, CMD, cmd_flags | SDMMC_CMD_START |
+		   (host->cur_slot->id << SDMMC_CMD_CARD_NUM_OFFSET));
 
 	/* response expected command only */
 	if (cmd_flags & SDMMC_CMD_RESP_EXP)
@@ -526,7 +504,7 @@ static void dw_mci_dmac_complete_dma(void *arg)
 	if ((host->use_dma == TRANS_MODE_EDMAC) &&
 	    data && (data->flags & MMC_DATA_READ))
 		/* Invalidate cache after read */
-		dma_sync_sg_for_cpu(mmc_dev(host->slot->mmc),
+		dma_sync_sg_for_cpu(mmc_dev(host->cur_slot->mmc),
 				    data->sg,
 				    data->sg_len,
 				    DMA_FROM_DEVICE);
@@ -868,7 +846,7 @@ static int dw_mci_edmac_start_dma(struct dw_mci *host,
 
 	/* Flush cache before write */
 	if (host->data->flags & MMC_DATA_WRITE)
-		dma_sync_sg_for_device(mmc_dev(host->slot->mmc), sgl,
+		dma_sync_sg_for_device(mmc_dev(host->cur_slot->mmc), sgl,
 				       sg_elems, DMA_TO_DEVICE);
 
 	dma_async_issue_pending(host->dms->ch);
@@ -1089,7 +1067,7 @@ static void dw_mci_ctrl_thld(struct dw_mci *host, struct mmc_data *data)
 	 * It's used when HS400 mode is enabled.
 	 */
 	if (data->flags & MMC_DATA_WRITE &&
-		!(host->timing != MMC_TIMING_MMC_HS400))
+		!(host->cur_slot->timing != MMC_TIMING_MMC_HS400))
 		return;
 
 	if (data->flags & MMC_DATA_WRITE)
@@ -1097,8 +1075,8 @@ static void dw_mci_ctrl_thld(struct dw_mci *host, struct mmc_data *data)
 	else
 		enable = SDMMC_CARD_RD_THR_EN;
 
-	if (host->timing != MMC_TIMING_MMC_HS200 &&
-	    host->timing != MMC_TIMING_UHS_SDR104)
+	if (host->cur_slot->timing != MMC_TIMING_MMC_HS200 &&
+	    host->cur_slot->timing != MMC_TIMING_UHS_SDR104)
 		goto disable;
 
 	blksz_depth = blksz / (1 << host->data_shift);
@@ -1242,13 +1220,45 @@ static void dw_mci_submit_data(struct dw_mci *host, struct mmc_data *data)
 	}
 }
 
-static void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)
+/* must be called in the locked context */
+static void dw_mci_setup_clock_off(struct dw_mci_slot *slot)
+{
+	u32 sdmmc_cmd_bits = SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT |
+			     (slot->id << SDMMC_CMD_CARD_NUM_OFFSET);
+
+	if (!slot->host->new_clk_speed) {
+		mci_writel(slot->host, CLKENA, 0);
+		mci_send_cmd(slot, sdmmc_cmd_bits, 0);
+		slot->host->current_speed = 0;
+	}
+}
+
+static u32 dw_mci_calc_clock_div(struct dw_mci *host)
+{
+	unsigned int clock = host->new_clk_speed;
+	u32 bus_hz = host->bus_hz;
+	u32 div;
+
+	div = bus_hz / clock;
+	if (bus_hz % clock && bus_hz > clock)
+		/*
+		 * move the + 1 after the divide to prevent
+		 * over-clocking the card.
+		 */
+		div += 1;
+
+	return (bus_hz != clock) ? DIV_ROUND_UP(div, 2) : 0;
+}
+
+/* must be called in the locked context */
+static void dw_mci_setup_clock(struct dw_mci_slot *slot, bool force_clkinit)
 {
 	struct dw_mci *host = slot->host;
-	unsigned int clock = slot->clock;
+	unsigned int clock = host->new_clk_speed;
 	u32 div;
 	u32 clk_en_a;
-	u32 sdmmc_cmd_bits = SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT;
+	u32 sdmmc_cmd_bits = SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT |
+			     (slot->id << SDMMC_CMD_CARD_NUM_OFFSET);
 
 	/* We must continue to set bit 28 in CMD until the change is complete */
 	if (host->state == STATE_WAITING_CMD11_DONE)
@@ -1257,79 +1267,174 @@ static void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)
 	if (!clock) {
 		mci_writel(host, CLKENA, 0);
 		mci_send_cmd(slot, sdmmc_cmd_bits, 0);
-	} else if (clock != host->current_speed || force_clkinit) {
-		div = host->bus_hz / clock;
-		if (host->bus_hz % clock && host->bus_hz > clock)
-			/*
-			 * move the + 1 after the divide to prevent
-			 * over-clocking the card.
-			 */
-			div += 1;
-
-		div = (host->bus_hz != clock) ? DIV_ROUND_UP(div, 2) : 0;
+		host->current_speed = 0;
 
-		if ((clock != slot->__clk_old &&
-			!test_bit(DW_MMC_CARD_NEEDS_POLL, &slot->flags)) ||
-			force_clkinit) {
-			/* Silent the verbose log if calling from PM context */
-			if (!force_clkinit)
-				dev_info(&slot->mmc->class_dev,
-					 "Bus speed (slot %d) = %dHz (slot req %dHz, actual %dHZ div = %d)\n",
-					 slot->id, host->bus_hz, clock,
-					 div ? ((host->bus_hz / div) >> 1) :
-					 host->bus_hz, div);
+		return;
+	}
 
-			/*
-			 * If card is polling, display the message only
-			 * one time at boot time.
-			 */
-			if (slot->mmc->caps & MMC_CAP_NEEDS_POLL &&
-					slot->mmc->f_min == clock)
-				set_bit(DW_MMC_CARD_NEEDS_POLL, &slot->flags);
-		}
+	if (clock != host->current_speed || force_clkinit) {
+		div = dw_mci_calc_clock_div(host);
 
-		/* disable clock */
-		mci_writel(host, CLKENA, 0);
+		/*
+		 * Stop all clocks by writing xxxx0000 to the CLKENA register.
+		 * We don't want to touch LOW_PWR bits to avoid changing for
+		 * another slot.
+		 */
+		clk_en_a = mci_readl(host, CLKENA);
+		clk_en_a &= ~SDMMC_CLKEN_CLK_ALL;
+		mci_writel(host, CLKENA, clk_en_a);
 		mci_writel(host, CLKSRC, 0);
-
-		/* inform CIU */
+		/* inform CIU about clock disabling */
 		mci_send_cmd(slot, sdmmc_cmd_bits, 0);
 
 		/* set clock to desired speed */
 		mci_writel(host, CLKDIV, div);
-
-		/* inform CIU */
+		/* inform CIU about CLKDIV change */
 		mci_send_cmd(slot, sdmmc_cmd_bits, 0);
 
 		/* enable clock; only low power if no SDIO */
-		clk_en_a = SDMMC_CLKEN_ENABLE << slot->id;
-		if (!test_bit(DW_MMC_CARD_NO_LOW_PWR, &slot->flags))
+		clk_en_a = mci_readl(host, CLKENA);
+		clk_en_a |= SDMMC_CLKEN_ENABLE << slot->id;
+		if (test_bit(DW_MMC_CARD_NO_LOW_PWR, &slot->flags))
+			clk_en_a &= ~(SDMMC_CLKEN_LOW_PWR << slot->id);
+		else
 			clk_en_a |= SDMMC_CLKEN_LOW_PWR << slot->id;
 		mci_writel(host, CLKENA, clk_en_a);
-
-		/* inform CIU */
+		/*
+		 * Inform CIU about clock enabling and (possibly) LOW_PWR bit
+		 * change.
+		 */
 		mci_send_cmd(slot, sdmmc_cmd_bits, 0);
 
-		/* keep the last clock value that was requested from core */
-		slot->__clk_old = clock;
+		host->current_speed = clock;
+	}
+}
+
+/* must be called with host->lock held */
+static void dw_mci_setup_timings(struct dw_mci_slot *slot, u8 timing)
+{
+	u32 reg;
+
+	slot->timing = timing;
+
+	/* Set the current slot timings */
+	reg = mci_readl(slot->host, UHS_REG);
+
+	/* DDR mode set */
+	if (timing == MMC_TIMING_MMC_DDR52 ||
+	    timing == MMC_TIMING_UHS_DDR50 ||
+	    timing == MMC_TIMING_MMC_HS400)
+		reg |= ((0x1 << slot->id) << 16);
+	else
+		reg &= ~((0x1 << slot->id) << 16);
+
+	mci_writel(slot->host, UHS_REG, reg);
+}
+
+/* must be called with host->lock held */
+static void dw_mci_calc_common_clock(struct dw_mci_slot *slot)
+{
+	struct dw_mci *host = slot->host;
+	u32 clock_min = ~0U;
+	int i;
+
+	/*
+	 * Calculate new clock which is suitable for all slots and save it in
+	 * host->new_clk_speed
+	 */
+	for (i = 0; i < host->num_slots; i++) {
+		if (host->slot[i] &&
+		    host->slot[i]->clock &&
+		    host->slot[i]->clock < clock_min) {
+			clock_min = host->slot[i]->clock;
+		}
 	}
 
-	host->current_speed = clock;
+	/* all slots have clock == 0 */
+	if (clock_min == ~0U)
+		clock_min = 0;
+
+	host->new_clk_speed = clock_min;
+
+	if (clock_min != host->current_speed)
+		dev_vdbg(host->dev, "[%u] ios: choose new common clock: %u\n",
+			 slot->id, clock_min);
+}
+
+/* must be called with host->lock held */
+static void dw_mci_setup_bus_width(struct dw_mci_slot *slot, u8 bus_width)
+{
+	u32 reg;
+
+	switch (bus_width) {
+	case MMC_BUS_WIDTH_4:
+		slot->ctype = SDMMC_CTYPE_4BIT;
+		break;
+	case MMC_BUS_WIDTH_8:
+		slot->ctype = SDMMC_CTYPE_8BIT;
+		break;
+	default:
+		/* set default 1 bit mode */
+		slot->ctype = SDMMC_CTYPE_1BIT;
+	}
 
 	/* Set the current slot bus width */
-	mci_writel(host, CTYPE, (slot->ctype << slot->id));
+	reg = mci_readl(slot->host, CTYPE);
+	reg &= ~((SDMMC_CTYPE_8BIT | SDMMC_CTYPE_4BIT | SDMMC_CTYPE_1BIT) << slot->id);
+	reg |= slot->ctype << slot->id;
+	mci_writel(slot->host, CTYPE, reg);
+}
+
+static void dw_mci_switch_card(struct dw_mci *host, struct dw_mci_slot *prev_slot)
+{
+	struct dw_mci_slot *slot = host->cur_slot;
+	u32 new_id = host->cur_slot->id;
+	u32 clk_en;
+
+	if (!prev_slot)
+		return;
+
+	if (prev_slot->id == new_id)
+		return;
+
+	dev_vdbg(host->dev, "[%u->%u] slot change\n", prev_slot->id, new_id);
+
+	/* Stop all clocks by writing xxxx0000 to the CLKENA register. */
+	clk_en = mci_readl(host, CLKENA);
+	clk_en &= ~SDMMC_CLKEN_CLK_ALL;
+	mci_writel(host, CLKENA, clk_en);
+
+	/* Inform CIU about clock disabling. */
+	mci_send_cmd(slot, SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
+
+	/* Enable clock, carry about new slot LOW_PWR bit */
+	if (test_bit(DW_MMC_CARD_NO_LOW_PWR, &slot->flags))
+		clk_en &= ~(SDMMC_CLKEN_LOW_PWR << new_id);
+	else
+		clk_en |= SDMMC_CLKEN_LOW_PWR << new_id;
+	clk_en |= SDMMC_CLKEN_ENABLE << new_id;
+	mci_writel(host, CLKENA, clk_en);
+
+	/*
+	 * Inform CIU about clock enabling and (possibly) LOW_PWR bit
+	 * change.
+	 */
+	mci_send_cmd(slot, SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
 }
 
 static void __dw_mci_start_request(struct dw_mci *host,
 				   struct dw_mci_slot *slot,
 				   struct mmc_command *cmd)
 {
+	struct dw_mci_slot *prev_slot;
 	struct mmc_request *mrq;
 	struct mmc_data	*data;
 	u32 cmdflags;
 
 	mrq = slot->mrq;
 
+	prev_slot = host->cur_slot;
+	host->cur_slot = slot;
 	host->mrq = mrq;
 
 	host->pending_events = 0;
@@ -1338,6 +1443,12 @@ static void __dw_mci_start_request(struct dw_mci *host,
 	host->data_status = 0;
 	host->dir_status = 0;
 
+	/* Change common clock frequency if it is required */
+	dw_mci_setup_clock(slot, false);
+
+	/* Swithch to another slot if it is required */
+	dw_mci_switch_card(host, prev_slot);
+
 	data = cmd->data;
 	if (data) {
 		mci_writel(host, TMOUT, 0xFFFFFFFF);
@@ -1445,6 +1556,20 @@ static void dw_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	spin_unlock_bh(&host->lock);
 }
 
+/* must be called with host->lock held */
+static u8 dw_mci_num_card_is_on(struct dw_mci *host)
+{
+	u8 num_card = 0;
+	int i;
+
+	for (i = 0; i < host->num_slots; i++)
+		if (host->slot[i])
+			if (test_bit(DW_MMC_CARD_IS_ON, &host->slot[i]->flags))
+				num_card++;
+
+	return num_card;
+}
+
 static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
 	struct dw_mci_slot *slot = mmc_priv(mmc);
@@ -1452,36 +1577,18 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	u32 regs;
 	int ret;
 
-	switch (ios->bus_width) {
-	case MMC_BUS_WIDTH_4:
-		slot->ctype = SDMMC_CTYPE_4BIT;
-		break;
-	case MMC_BUS_WIDTH_8:
-		slot->ctype = SDMMC_CTYPE_8BIT;
-		break;
-	default:
-		/* set default 1 bit mode */
-		slot->ctype = SDMMC_CTYPE_1BIT;
-	}
-
-	regs = mci_readl(slot->host, UHS_REG);
-
-	/* DDR mode set */
-	if (ios->timing == MMC_TIMING_MMC_DDR52 ||
-	    ios->timing == MMC_TIMING_UHS_DDR50 ||
-	    ios->timing == MMC_TIMING_MMC_HS400)
-		regs |= ((0x1 << slot->id) << 16);
-	else
-		regs &= ~((0x1 << slot->id) << 16);
+	spin_lock_bh(&slot->host->lock);
 
-	mci_writel(slot->host, UHS_REG, regs);
-	slot->host->timing = ios->timing;
+	dw_mci_setup_bus_width(slot, ios->bus_width);
+	dw_mci_setup_timings(slot, ios->timing);
 
 	/*
 	 * Use mirror of ios->clock to prevent race with mmc
 	 * core ios update when finding the minimum.
 	 */
 	slot->clock = ios->clock;
+	/* Calculate new clock which is suitable for all slots */
+	dw_mci_calc_common_clock(slot);
 
 	if (drv_data && drv_data->set_ios)
 		drv_data->set_ios(slot->host, ios);
@@ -1504,6 +1611,13 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		mci_writel(slot->host, PWREN, regs);
 		break;
 	case MMC_POWER_ON:
+		set_bit(DW_MMC_CARD_IS_ON, &slot->flags);
+
+		/*
+		 * Don't care about regulators and controller reset in
+		 * multislot mode as external regulators can't be used in
+		 * multislot mode. (we explicitly check it in probe function)
+		 */
 		if (!slot->host->vqmmc_enabled) {
 			if (!IS_ERR(mmc->supply.vqmmc)) {
 				ret = regulator_enable(mmc->supply.vqmmc);
@@ -1523,13 +1637,20 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 					  SDMMC_CTRL_ALL_RESET_FLAGS);
 		}
 
-		/* Adjust clock / bus width after power is up */
-		dw_mci_setup_bus(slot, false);
+		/*
+		 * If we are first controller user setup clock. Otherwise
+		 * clock will be adjusted before request.
+		 */
+		if (dw_mci_num_card_is_on(slot->host) == 1)
+			dw_mci_setup_clock(slot, false);
 
 		break;
 	case MMC_POWER_OFF:
-		/* Turn clock off before power goes down */
-		dw_mci_setup_bus(slot, false);
+		clear_bit(DW_MMC_CARD_IS_ON, &slot->flags);
+
+		/* set clock to 0 only if no other card is ON */
+		if (dw_mci_num_card_is_on(slot->host) == 0)
+			dw_mci_setup_clock_off(slot);
 
 		if (!IS_ERR(mmc->supply.vmmc))
 			mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);
@@ -1548,6 +1669,8 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 	if (slot->host->state == STATE_WAITING_CMD11_DONE && ios->clock != 0)
 		slot->host->state = STATE_IDLE;
+
+	spin_unlock_bh(&slot->host->lock);
 }
 
 static int dw_mci_card_busy(struct mmc_host *mmc)
@@ -1576,6 +1699,8 @@ static int dw_mci_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)
 	if (drv_data && drv_data->switch_voltage)
 		return drv_data->switch_voltage(mmc, ios);
 
+
+	spin_lock_bh(&slot->host->lock);
 	/*
 	 * Program the voltage.  Note that some instances of dw_mmc may use
 	 * the UHS_REG for this.  For other instances (like exynos) the UHS_REG
@@ -1586,6 +1711,8 @@ static int dw_mci_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)
 		uhs &= ~v18;
 	else
 		uhs |= v18;
+	mci_writel(host, UHS_REG, uhs);
+	spin_unlock_bh(&slot->host->lock);
 
 	if (!IS_ERR(mmc->supply.vqmmc)) {
 		ret = mmc_regulator_set_vqmmc(mmc, ios);
@@ -1597,7 +1724,6 @@ static int dw_mci_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)
 			return ret;
 		}
 	}
-	mci_writel(host, UHS_REG, uhs);
 
 	return 0;
 }
@@ -1664,6 +1790,7 @@ static void dw_mci_init_card(struct mmc_host *mmc, struct mmc_card *card)
 		u32 clk_en_a_old;
 		u32 clk_en_a;
 
+		spin_lock(&host->lock);
 		clk_en_a_old = mci_readl(host, CLKENA);
 
 		if (card->type == MMC_TYPE_SDIO ||
@@ -1680,6 +1807,7 @@ static void dw_mci_init_card(struct mmc_host *mmc, struct mmc_card *card)
 			mci_send_cmd(slot, SDMMC_CMD_UPD_CLK |
 				     SDMMC_CMD_PRV_DAT_WAIT, 0);
 		}
+		spin_unlock(&host->lock);
 	}
 }
 
@@ -1810,7 +1938,7 @@ static bool dw_mci_reset(struct dw_mci *host)
 
 ciu_out:
 	/* After a CTRL reset we need to have CIU set clock registers  */
-	mci_send_cmd(host->slot, SDMMC_CMD_UPD_CLK, 0);
+	mci_send_cmd(host->cur_slot, SDMMC_CMD_UPD_CLK, 0);
 
 	return ret;
 }
@@ -1837,11 +1965,11 @@ static void dw_mci_request_end(struct dw_mci *host, struct mmc_request *mrq)
 	__acquires(&host->lock)
 {
 	struct dw_mci_slot *slot;
-	struct mmc_host	*prev_mmc = host->slot->mmc;
+	struct mmc_host	*prev_mmc = host->cur_slot->mmc;
 
 	WARN_ON(host->cmd || host->data);
 
-	host->slot->mrq = NULL;
+	host->cur_slot->mrq = NULL;
 	host->mrq = NULL;
 	if (!list_empty(&host->queue)) {
 		slot = list_entry(host->queue.next,
@@ -1952,7 +2080,6 @@ static void dw_mci_set_drto(struct dw_mci *host)
 	drto_div = (mci_readl(host, CLKDIV) & 0xff) * 2;
 	if (drto_div == 0)
 		drto_div = 1;
-
 	drto_ms = DIV_ROUND_UP_ULL((u64)MSEC_PER_SEC * drto_clks * drto_div,
 				   host->bus_hz);
 
@@ -2030,8 +2157,7 @@ static void dw_mci_tasklet_func(unsigned long priv)
 			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
 			err = dw_mci_command_complete(host, cmd);
 			if (cmd == mrq->sbc && !err) {
-				prev_state = state = STATE_SENDING_CMD;
-				__dw_mci_start_request(host, host->slot,
+				__dw_mci_start_request(host, host->cur_slot,
 						       mrq->cmd);
 				goto unlock;
 			}
@@ -2650,20 +2776,27 @@ static void dw_mci_cmd_interrupt(struct dw_mci *host, u32 status)
 
 static void dw_mci_handle_cd(struct dw_mci *host)
 {
-	struct dw_mci_slot *slot = host->slot;
+	int i;
 
-	if (slot->mmc->ops->card_event)
-		slot->mmc->ops->card_event(slot->mmc);
-	mmc_detect_change(slot->mmc,
-		msecs_to_jiffies(host->pdata->detect_delay_ms));
+	for (i = 0; i < host->num_slots; i++) {
+		struct dw_mci_slot *slot = host->slot[i];
+
+		if (!slot)
+			continue;
+
+		if (slot->mmc->ops->card_event)
+			slot->mmc->ops->card_event(slot->mmc);
+		mmc_detect_change(slot->mmc,
+			msecs_to_jiffies(host->pdata->detect_delay_ms));
+	}
 }
 
 static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 {
+	unsigned long irqflags;
 	struct dw_mci *host = dev_id;
 	u32 pending;
-	struct dw_mci_slot *slot = host->slot;
-	unsigned long irqflags;
+	int i;
 
 	pending = mci_readl(host, MINTSTS); /* read-only mask reg */
 
@@ -2751,11 +2884,19 @@ static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 			dw_mci_handle_cd(host);
 		}
 
-		if (pending & SDMMC_INT_SDIO(slot->sdio_id)) {
-			mci_writel(host, RINTSTS,
-				   SDMMC_INT_SDIO(slot->sdio_id));
-			__dw_mci_enable_sdio_irq(slot, 0);
-			sdio_signal_irq(slot->mmc);
+		/* Handle SDIO Interrupts */
+		for (i = 0; i < host->num_slots; i++) {
+			struct dw_mci_slot *slot = host->slot[i];
+
+			if (!slot)
+				continue;
+
+			if (pending & SDMMC_INT_SDIO(slot->sdio_id)) {
+				mci_writel(host, RINTSTS,
+					   SDMMC_INT_SDIO(slot->sdio_id));
+				__dw_mci_enable_sdio_irq(slot, 0);
+				sdio_signal_irq(slot->mmc);
+			}
 		}
 
 	}
@@ -2826,6 +2967,10 @@ static int dw_mci_init_slot_caps(struct dw_mci_slot *slot)
 	if (host->pdata->caps2)
 		mmc->caps2 = host->pdata->caps2;
 
+	mmc->f_min = DW_MCI_FREQ_MIN;
+	if (!mmc->f_max)
+		mmc->f_max = DW_MCI_FREQ_MAX;
+
 	/* Process SDIO IRQs through the sdio_irq_work. */
 	if (mmc->caps & MMC_CAP_SDIO_IRQ)
 		mmc->caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;
@@ -2833,41 +2978,36 @@ static int dw_mci_init_slot_caps(struct dw_mci_slot *slot)
 	return 0;
 }
 
-static int dw_mci_init_slot(struct dw_mci *host)
+static int dw_mci_init_slot(struct dw_mci *host, unsigned int id)
 {
 	struct mmc_host *mmc;
 	struct dw_mci_slot *slot;
 	int ret;
-	u32 freq[2];
 
 	mmc = mmc_alloc_host(sizeof(struct dw_mci_slot), host->dev);
 	if (!mmc)
 		return -ENOMEM;
 
 	slot = mmc_priv(mmc);
-	slot->id = 0;
-	slot->sdio_id = host->sdio_id0 + slot->id;
+	slot->id = id;
+	slot->sdio_id = host->sdio_id0 + id;
 	slot->mmc = mmc;
 	slot->host = host;
-	host->slot = slot;
 
 	mmc->ops = &dw_mci_ops;
-	if (device_property_read_u32_array(host->dev, "clock-freq-min-max",
-					   freq, 2)) {
-		mmc->f_min = DW_MCI_FREQ_MIN;
-		mmc->f_max = DW_MCI_FREQ_MAX;
-	} else {
-		dev_info(host->dev,
-			"'clock-freq-min-max' property was deprecated.\n");
-		mmc->f_min = freq[0];
-		mmc->f_max = freq[1];
-	}
 
 	/*if there are external regulators, get them*/
 	ret = mmc_regulator_get_supply(mmc);
 	if (ret)
 		goto err_host_allocated;
 
+	if (host->num_slots > 1 &&
+	    (!IS_ERR(slot->mmc->supply.vmmc) || !IS_ERR(mmc->supply.vqmmc))) {
+		dev_err(host->dev,
+			"external regulators in multislot mode are not supported\n");
+		goto err_host_allocated;
+	}
+
 	if (!mmc->ocr_avail)
 		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
 
@@ -2905,6 +3045,9 @@ static int dw_mci_init_slot(struct dw_mci *host)
 
 	dw_mci_get_cd(mmc);
 
+	/* Add slot to the slot array only if it is allocated successfuly */
+	host->slot[id] = slot;
+
 	ret = mmc_add_host(mmc);
 	if (ret)
 		goto err_host_allocated;
@@ -2916,15 +3059,16 @@ static int dw_mci_init_slot(struct dw_mci *host)
 	return 0;
 
 err_host_allocated:
+	host->slot[id] = NULL;
 	mmc_free_host(mmc);
 	return ret;
 }
 
-static void dw_mci_cleanup_slot(struct dw_mci_slot *slot)
+static void dw_mci_cleanup_slot(struct dw_mci_slot *slot, unsigned int id)
 {
 	/* Debugfs stuff is cleaned up by mmc core */
 	mmc_remove_host(slot->mmc);
-	slot->host->slot = NULL;
+	slot->host->slot[id] = NULL;
 	mmc_free_host(slot->mmc);
 }
 
@@ -3161,8 +3305,7 @@ static struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)
 	}
 
 	/* find out number of slots supported */
-	if (!device_property_read_u32(dev, "num-slots", &pdata->num_slots))
-		dev_info(dev, "'num-slots' was deprecated.\n");
+	device_property_read_u32(dev, "num-slots", &pdata->num_slots);
 
 	if (device_property_read_u32(dev, "fifo-depth", &pdata->fifo_depth))
 		dev_info(dev,
@@ -3199,21 +3342,29 @@ static void dw_mci_enable_cd(struct dw_mci *host)
 {
 	unsigned long irqflags;
 	u32 temp;
+	int i;
+	struct dw_mci_slot *slot;
 
 	/*
 	 * No need for CD if all slots have a non-error GPIO
 	 * as well as broken card detection is found.
 	 */
-	if (host->slot->mmc->caps & MMC_CAP_NEEDS_POLL)
-		return;
+	for (i = 0; i < host->num_slots; i++) {
+		slot = host->slot[i];
+		if (slot->mmc->caps & MMC_CAP_NEEDS_POLL)
+			return;
 
-	if (mmc_gpio_get_cd(host->slot->mmc) < 0) {
-		spin_lock_irqsave(&host->irq_lock, irqflags);
-		temp = mci_readl(host, INTMASK);
-		temp  |= SDMMC_INT_CD;
-		mci_writel(host, INTMASK, temp);
-		spin_unlock_irqrestore(&host->irq_lock, irqflags);
+		if (mmc_gpio_get_cd(slot->mmc) < 0)
+			break;
 	}
+	if (i == host->num_slots)
+		return;
+
+	spin_lock_irqsave(&host->irq_lock, irqflags);
+	temp = mci_readl(host, INTMASK);
+	temp  |= SDMMC_INT_CD;
+	mci_writel(host, INTMASK, temp);
+	spin_unlock_irqrestore(&host->irq_lock, irqflags);
 }
 
 int dw_mci_probe(struct dw_mci *host)
@@ -3221,6 +3372,7 @@ int dw_mci_probe(struct dw_mci *host)
 	const struct dw_mci_drv_data *drv_data = host->drv_data;
 	int width, i, ret = 0;
 	u32 fifo_size;
+	int init_slots = 0;
 
 	if (!host->pdata) {
 		host->pdata = dw_mci_parse_dt(host);
@@ -3381,6 +3533,20 @@ int dw_mci_probe(struct dw_mci *host)
 	if (ret)
 		goto err_dmaunmap;
 
+	if (host->pdata->num_slots)
+		host->num_slots = host->pdata->num_slots;
+	else
+		host->num_slots = 1;
+
+	if (host->num_slots < 1 ||
+	    host->num_slots > SDMMC_GET_SLOT_NUM(mci_readl(host, HCON)) ||
+	    host->num_slots > MAX_MCI_SLOTS) {
+		dev_err(host->dev,
+			"Platform data must supply correct num_slots.\n");
+		ret = -ENODEV;
+		goto err_clk_ciu;
+	}
+
 	/*
 	 * Enable interrupts for command done, data over, data empty,
 	 * receive ready and error such as transmit, receive timeout, crc error
@@ -3396,9 +3562,20 @@ int dw_mci_probe(struct dw_mci *host)
 		 host->irq, width, fifo_size);
 
 	/* We need at least one slot to succeed */
-	ret = dw_mci_init_slot(host);
-	if (ret) {
-		dev_dbg(host->dev, "slot %d init failed\n", i);
+	for (i = 0; i < host->num_slots; i++) {
+		ret = dw_mci_init_slot(host, i);
+		if (ret)
+			dev_dbg(host->dev, "slot %d init failed\n", i);
+		else
+			init_slots++;
+	}
+
+	if (init_slots) {
+		dev_info(host->dev, "%d slots initialized\n", init_slots);
+	} else {
+		dev_dbg(host->dev,
+			"attempted to initialize %d slots, but failed on all\n",
+			host->num_slots);
 		goto err_dmaunmap;
 	}
 
@@ -3426,9 +3603,13 @@ EXPORT_SYMBOL(dw_mci_probe);
 
 void dw_mci_remove(struct dw_mci *host)
 {
-	dev_dbg(host->dev, "remove slot\n");
-	if (host->slot)
-		dw_mci_cleanup_slot(host->slot);
+	int i;
+
+	for (i = 0; i < host->num_slots; i++) {
+		dev_dbg(host->dev, "remove slot %d\n", i);
+		if (host->slot[i])
+			dw_mci_cleanup_slot(host->slot[i], i);
+	}
 
 	mci_writel(host, RINTSTS, 0xFFFFFFFF);
 	mci_writel(host, INTMASK, 0); /* disable all mmc interrupt first */
@@ -3460,9 +3641,9 @@ int dw_mci_runtime_suspend(struct device *dev)
 
 	clk_disable_unprepare(host->ciu_clk);
 
-	if (host->slot &&
-	    (mmc_can_gpio_cd(host->slot->mmc) ||
-	     !mmc_card_is_removable(host->slot->mmc)))
+	if (host->cur_slot &&
+	    (mmc_can_gpio_cd(host->cur_slot->mmc) ||
+	     !mmc_card_is_removable(host->cur_slot->mmc)))
 		clk_disable_unprepare(host->biu_clk);
 
 	return 0;
@@ -3471,12 +3652,12 @@ EXPORT_SYMBOL(dw_mci_runtime_suspend);
 
 int dw_mci_runtime_resume(struct device *dev)
 {
-	int ret = 0;
+	int i, ret = 0;
 	struct dw_mci *host = dev_get_drvdata(dev);
 
-	if (host->slot &&
-	    (mmc_can_gpio_cd(host->slot->mmc) ||
-	     !mmc_card_is_removable(host->slot->mmc))) {
+	if (host->cur_slot &&
+	    (mmc_can_gpio_cd(host->cur_slot->mmc) ||
+	     !mmc_card_is_removable(host->cur_slot->mmc))) {
 		ret = clk_prepare_enable(host->biu_clk);
 		if (ret)
 			return ret;
@@ -3511,12 +3692,17 @@ int dw_mci_runtime_resume(struct device *dev)
 		   DW_MCI_ERROR_FLAGS);
 	mci_writel(host, CTRL, SDMMC_CTRL_INT_ENABLE);
 
+	for (i = 0; i < host->num_slots; i++) {
+		struct dw_mci_slot *slot = host->slot[i];
 
-	if (host->slot->mmc->pm_flags & MMC_PM_KEEP_POWER)
-		dw_mci_set_ios(host->slot->mmc, &host->slot->mmc->ios);
+		if (!slot)
+			continue;
+		if (slot->mmc->pm_flags & MMC_PM_KEEP_POWER)
+			dw_mci_set_ios(slot->mmc, &slot->mmc->ios);
 
-	/* Force setup bus to guarantee available clock output */
-	dw_mci_setup_bus(host->slot, true);
+		/* Force setup bus to guarantee available clock output */
+		dw_mci_setup_clock(slot, true);
+	}
 
 	/* Now that slots are all setup, we can enable card detect */
 	dw_mci_enable_cd(host);
@@ -3524,9 +3710,9 @@ int dw_mci_runtime_resume(struct device *dev)
 	return 0;
 
 err:
-	if (host->slot &&
-	    (mmc_can_gpio_cd(host->slot->mmc) ||
-	     !mmc_card_is_removable(host->slot->mmc)))
+	if (host->cur_slot &&
+	    (mmc_can_gpio_cd(host->cur_slot->mmc) ||
+	     !mmc_card_is_removable(host->cur_slot->mmc)))
 		clk_disable_unprepare(host->biu_clk);
 
 	return ret;
diff --git a/drivers/mmc/host/dw_mmc.h b/drivers/mmc/host/dw_mmc.h
index 1424bd490dd1..47d7f20be4de 100644
--- a/drivers/mmc/host/dw_mmc.h
+++ b/drivers/mmc/host/dw_mmc.h
@@ -20,6 +20,8 @@
 #include <linux/reset.h>
 #include <linux/interrupt.h>
 
+#define MAX_MCI_SLOTS	2
+
 enum dw_mci_state {
 	STATE_IDLE = 0,
 	STATE_SENDING_CMD,
@@ -73,7 +75,6 @@ struct dw_mci_dma_slave {
  *	transfer is in progress.
  * @stop_abort: The command currently prepared for stoping transfer.
  * @prev_blksz: The former transfer blksz record.
- * @timing: Record of current ios timing.
  * @use_dma: Which DMA channel is in use for the current transfer, zero
  *	denotes PIO mode.
  * @using_dma: Whether DMA is in use for the current transfer.
@@ -101,7 +102,10 @@ struct dw_mci_dma_slave {
  * @queue: List of slots waiting for access to the controller.
  * @bus_hz: The rate of @mck in Hz. This forms the basis for MMC bus
  *	rate and timeout calculations.
- * @current_speed: Configured rate of the controller.
+ * @current_speed: Current clock rate of the controller.
+ * @new_clk_speed: New clock rate of the controller which is suitable for all
+ *	slots. It is calculated in set_ios function. After applyimg it
+ *	becomes @current_speed.
  * @num_slots: Number of slots available.
  * @fifoth_val: The value of FIFOTH register.
  * @verid: Denote Version ID.
@@ -134,6 +138,7 @@ struct dw_mci_dma_slave {
  * =======
  *
  * @lock is a softirq-safe spinlock protecting @queue as well as
+ * @cur_slot, @mrq and @state. These must always be updated
  * at the same time while holding @lock.
  *
  * @irq_lock is an irq-safe spinlock protecting the INTMASK register
@@ -169,12 +174,12 @@ struct dw_mci {
 	struct scatterlist	*sg;
 	struct sg_mapping_iter	sg_miter;
 
+	struct dw_mci_slot	*cur_slot;
 	struct mmc_request	*mrq;
 	struct mmc_command	*cmd;
 	struct mmc_data		*data;
 	struct mmc_command	stop_abort;
 	unsigned int		prev_blksz;
-	unsigned char		timing;
 
 	/* DMA interface members*/
 	int			use_dma;
@@ -204,6 +209,8 @@ struct dw_mci {
 
 	u32			bus_hz;
 	u32			current_speed;
+	u32			new_clk_speed;
+	u32			num_slots;
 	u32			fifoth_val;
 	u16			verid;
 	struct device		*dev;
@@ -212,7 +219,7 @@ struct dw_mci {
 	void			*priv;
 	struct clk		*biu_clk;
 	struct clk		*ciu_clk;
-	struct dw_mci_slot	*slot;
+	struct dw_mci_slot	*slot[MAX_MCI_SLOTS];
 
 	/* FIFO push and pull */
 	int			fifo_depth;
@@ -318,11 +325,12 @@ struct dw_mci_board {
 #define SDMMC_BUFADDR		0x098
 #define SDMMC_CDTHRCTL		0x100
 #define SDMMC_UHS_REG_EXT	0x108
+#define SDMMC_DDR_REG		0x10c
 #define SDMMC_ENABLE_SHIFT	0x110
 #define SDMMC_DATA(x)		(x)
 /*
-* Registers to support idmac 64-bit address mode
-*/
+ * Registers to support idmac 64-bit address mode
+ */
 #define SDMMC_DBADDRL		0x088
 #define SDMMC_DBADDRU		0x08c
 #define SDMMC_IDSTS64		0x090
@@ -358,6 +366,7 @@ struct dw_mci_board {
 /* Clock Enable register defines */
 #define SDMMC_CLKEN_LOW_PWR		BIT(16)
 #define SDMMC_CLKEN_ENABLE		BIT(0)
+#define SDMMC_CLKEN_CLK_ALL		0xFFFF
 /* time-out register defines */
 #define SDMMC_TMOUT_DATA(n)		_SBF(8, (n))
 #define SDMMC_TMOUT_DATA_MSK		0xFFFFFF00
@@ -405,6 +414,7 @@ struct dw_mci_board {
 #define SDMMC_CMD_RESP_LONG		BIT(7)
 #define SDMMC_CMD_RESP_EXP		BIT(6)
 #define SDMMC_CMD_INDX(n)		((n) & 0x1F)
+#define SDMMC_CMD_CARD_NUM_OFFSET	16
 /* Status register defines */
 #define SDMMC_GET_FCNT(x)		(((x)>>17) & 0x1FFF)
 #define SDMMC_STATUS_DMA_REQ		BIT(31)
@@ -443,13 +453,19 @@ struct dw_mci_board {
 #define SDMMC_CARD_WR_THR_EN		BIT(2)
 #define SDMMC_CARD_RD_THR_EN		BIT(0)
 /* UHS-1 register defines */
+#define SDMMC_UHS_DDR			BIT(16)
 #define SDMMC_UHS_18V			BIT(0)
+/* DDR register defines */
+#define SDMMC_DDR_HS400			BIT(31)
+/* Enable shift register defines */
+#define SDMMC_ENABLE_PHASE		BIT(0)
 /* All ctrl reset bits */
 #define SDMMC_CTRL_ALL_RESET_FLAGS \
 	(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET)
 
 /* FIFO register access macros. These should not change the data endian-ness
- * as they are written to memory to be dealt with by the upper layers */
+ * as they are written to memory to be dealt with by the upper layers
+ */
 #define mci_fifo_readw(__reg)	__raw_readw(__reg)
 #define mci_fifo_readl(__reg)	__raw_readl(__reg)
 #define mci_fifo_readq(__reg)	__raw_readq(__reg)
@@ -507,6 +523,7 @@ extern int dw_mci_runtime_resume(struct device *device);
  * @mmc: The mmc_host representing this slot.
  * @host: The MMC controller this slot is using.
  * @ctype: Card type for this slot.
+ * @timing: Record of current ios timing for this slot.
  * @mrq: mmc_request currently being processed or waiting to be
  *	processed, or NULL when the slot is idle.
  * @queue_node: List node for placing this node in the @queue list of
@@ -523,12 +540,12 @@ struct dw_mci_slot {
 	struct dw_mci		*host;
 
 	u32			ctype;
+	unsigned char		timing;
 
 	struct mmc_request	*mrq;
 	struct list_head	queue_node;
 
 	unsigned int		clock;
-	unsigned int		__clk_old;
 
 	unsigned long		flags;
 #define DW_MMC_CARD_PRESENT	0
@@ -536,6 +553,7 @@ struct dw_mci_slot {
 #define DW_MMC_CARD_NO_LOW_PWR	2
 #define DW_MMC_CARD_NO_USE_HOLD 3
 #define DW_MMC_CARD_NEEDS_POLL	4
+#define DW_MMC_CARD_IS_ON	5
 	int			id;
 	int			sdio_id;
 };
-- 
2.16.2

