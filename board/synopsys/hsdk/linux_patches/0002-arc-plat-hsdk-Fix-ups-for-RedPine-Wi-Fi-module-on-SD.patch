From 2830c9122f5455d467dce2565da8b70fb25a46a7 Mon Sep 17 00:00:00 2001
From: Evgeniy Didin <Evgeniy.Didin@synopsys.com>
Date: Tue, 14 Jan 2020 09:58:26 +0300
Subject: [PATCH 2/2] arc: [plat-hsdk]: Fix-ups for RedPine Wi-Fi module on
 SDIO bus

We need to do 2 extra things:
 1) Configure internal and external signal multiplexers so
    SDIO signals might finally reach RedPine module, otherwise
    by default they are used for EBI interface.
 2) Configure external clock generator so both "cclk_in_drv"
    and "cclk_in_sample" have phase shift of 90 degrees.
    Otherwise RedPine module won't work!

This actually should be done in either h/arc/plat-hsdk/platform.c
or in drivers/mmc/host/dw_mmc_hsdk.c.

Also we hard-code slot #1 (instead of default #0) to be used
as that's the one wired to RedPine.

Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
Signed-off-by: Evgeniy Didin <Evgeniy.Didin@synopsys.com>
---
 drivers/mmc/host/dw_mmc.c | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
index 5e33ac69cc0e..f4e7d6029ae7 100644
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@ -1254,6 +1254,12 @@ static void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)
 		/* set clock to desired speed */
 		mci_writel(host, CLKDIV, div);
 
+		/*
+		 * UHS_REG_EXT[24:23] -> clk_drv_phase_ctrl[1:0] = 1 -> 90 degrees
+		 * UHS_REG_EXT[17:16] -> clk_sample_phase_ctrl[1:0] = 1 -> 90 degrees
+		 */
+		*(u32*)0xf000A108 = 0x00810000;
+
 		/* inform CIU */
 		mci_send_cmd(slot, sdmmc_cmd_bits, 0);
 
@@ -1459,7 +1465,14 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		set_bit(DW_MMC_CARD_NEED_INIT, &slot->flags);
 		regs = mci_readl(slot->host, PWREN);
 		regs |= (1 << slot->id);
+		/* Set PWREN[2] to disable EBI */
+		regs |= (1 << 2);
 		mci_writel(slot->host, PWREN, regs);
+		/* Drive high ebi_addr[18] to enable level shifter IC20 */
+		regs = mci_readl(slot->host, GPIO);
+		regs |= (1 << 13);
+		mci_writel(slot->host, GPIO, regs);
+
 		break;
 	case MMC_POWER_ON:
 		if (!slot->host->vqmmc_enabled) {
@@ -2804,7 +2817,7 @@ static int dw_mci_init_slot(struct dw_mci *host)
 		return -ENOMEM;
 
 	slot = mmc_priv(mmc);
-	slot->id = 0;
+	slot->id = 1;
 	slot->sdio_id = host->sdio_id0 + slot->id;
 	slot->mmc = mmc;
 	slot->host = host;
-- 
2.16.2

